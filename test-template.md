# テンプレートをヘッダーに書く必要性

```c++
// header.h
template <class T>
T f();

// impl.cpp
#include <header.h>
template <class T>
T f(){return T{};}

// main.cpp
#include <header.h>

int main()
{
    int x = f<int>();
}
```
例えば上記の構成はコンパイル可能だが、リンクエラーになる。
main関数は宣言を確認できるので、リンク手前までは正常に進む。
一方でimpl.cpp内ではテンプレート関数を利用していないため、コンパイラは実体を生成しない（コンパイラはテンプレート関数を明示的に利用したタイミングで実体を生成する。よく考えるとそれは当然で、コンパイルはcpp単位で行われ、今の場合定義が書いてあるimpl.cpp内の情報だけから必要な実体化が行われる。他のファイルでどんな実体化が必要かなんてimpl.cppは分かりようがないから、impl.cpp内で使われているもののみ実体化される）。
そのため、リンク時にmain関数は実体を確認しに行くが、その実体がない為、リンクエラーとなる。

解決策としてはヘッダーに実装を書くのが一番良い。

また他の可能性としては明示的なテンプレート化がある。
以下のようにすると、cppファイル内で利用していなくても実体化してくれるらしい。
```c++
// impl.cpp
#include <header.h>
template <class T>
T f(){return T{};}

template int f();
```



# テンプレートの特殊化とオーバーロードの解決
パターン１
```c++
template <class T> void f(T);
template <class T> void f(T*);
template <> void f<int>(int*); <--- f(T*)の特殊化 ---
                                                   |
f(new int()); <--- call f<int>(int*) ---------------
```
パターン２
```c++
template <class T> void f(T);
template <> void f<int*>(int*); <--- f(T)の特殊化
template <class T> void f(T*); <--
                                  |
f(new int()); <--- call f(T*) ----
```
テンプレートの特殊化よりも前にオーバーロード解決を行うらしい。

パターン１の場合、オーバーロード解決を先に行う為、三行目が一旦無視され、一行目と二行目で解決が走り、二行目が選ばれる。その後、そのオーバーロード解決されたテンプレート関数の特殊化である三行目が選ばれる。

パターン２の場合も同様、まずオーバーロード解決で二行目が一旦無視され、一行目と三行目の間で解決が走り、三行目が選ばれる。ここで二行目はあくまで一行目の特殊化なので、三行目が今回は選ばれる。